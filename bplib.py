#!/usr/bin/env python3
# -*- coding: utf8 -*-
################################################################################
##
## Copyright (C) 2012 Typhos
##
## This Source Code Form is subject to the terms of the Mozilla Public
## License, v. 2.0. If a copy of the MPL was not distributed with this
## file, You can obtain one at http://mozilla.org/MPL/2.0/.
##
################################################################################

import itertools
import time

Timestamp = time.strftime("Generated at %c.")

def px(pixels):
    return "%spx" % (pixels)

def write_autogen_warning(file):
    file.write("""
/*
 * This file is AUTOMATICALLY GENERATED. DO NOT EDIT.
 * %s
 */
""" % Timestamp)

class CssGenerator:
    def __init__(self, file):
        self.file = file
        write_autogen_warning(file)
        self.current_section = None

    def begin_section(self, section):
        if self.current_section is None or section != self.current_section:
            self.file.write("\n")
            self.file.write("/* %s */\n" % (section))
            self.current_section = section

    def selector(self, section, name):
        #return ".betterponymotes-%s-%s" % (section, name)
        return ".bpmotes-%s" % (name)

    def write_class(self, name, props):
        self.file.write("%s { %s; }\n" % (name, self.format_properties(props)))

    def format_properties(self, props):
        assert all(isinstance(val, str) for val in props.values()) # No implicit conversions...
        return "; ".join(("%s: %s" % (property, value)) for (property, value) in props.items())

    def close(self):
        self.file.close()

class JsGenerator:
    def __init__(self, file):
        self.file = file
        self._write_newline = False
        write_autogen_warning(file)
        self.file.write("\n")
        self.file.write("var emote_map = {")
        self.current_section = None
        self.pending_section = False

    def begin_section(self, section):
        if self.current_section is None or section != self.current_section:
            self.current_section = section
            self.pending_section = True

    def map_link(self, path, css_class):
        if self.pending_section:
            if self._write_newline:
                self.file.write(",\n")
            self._write_newline = False
            self.file.write("\n    /* %s */\n" % (self.current_section))
            self.pending_section = False

        assert css_class.startswith(".")
        css_class = css_class.lstrip(".") # Strip it off; JS doesn't expect a dot

        if self._write_newline:
            self.file.write(",\n")
        self.file.write("    %r: %r" % (path, css_class))
        self._write_newline = True

    def close(self):
        self.file.write("\n}\n")
        self.file.close()

class Output:
    def __init__(self, css, js):
        self.css = css
        self.js = js

    def begin_section(self, header):
        self.css.begin_section(header)
        self.js.begin_section(header)

    def close(self):
        self.css.close()
        self.js.close()

class Spritesheet:
    def __init__(self, section, image_url, emotes, common_css_props={}):
        self.section = section
        self.image_url = image_url
        self.emotes = emotes
        self.common_css_props = {
            "display": "block",
            "clear": "none",
            "float": "left",
            "background-image": "url(%s)" % (image_url)
            }
        self.common_css_props.update(common_css_props)

    def __call__(self, out):
        out.begin_section("%s spritesheet" % (self.section))

        for emote in self.emotes:
            assert all(name.startswith("/") for name in emote.names)
            selectors = [out.css.selector(self.section, name.lstrip("/")) for name in emote.names]
            props = self.common_css_props.copy()
            props.update(emote.css_props)

            out.css.write_class(", ".join(selectors), props)
            for (name, selector) in zip(emote.names, selectors):
                out.js.map_link(name, selector)

class Emote:
    def __init__(self, size, offset, *names, extra_css_props={}):
        self.size = size
        self.offset = offset
        self.names = names
        self.css_props = {
            "width": px(size[0]),
            "height": px(size[1]),
            "background-position": "%s %s" % (px(offset[0]), px(offset[1]))
            }
        self.css_props.update(extra_css_props)

class PsuedoEmote:
    def __init__(self, section, name, css_props):
        self.section = section
        self.name = name
        self.css_props = css_props

    def __call__(self, out):
        out.begin_section(self.section) # Hmm...
        selector = out.css.selector(self.section, self.name.lstrip("/"))
        out.css.write_class(selector, self.css_props)
        out.js.map_link(self.name, selector)

class CustomCss:
    def __init__(self, section, selector, props):
        self.section = section
        self.selector = selector
        self.props = props

    def __call__(self, out):
        out.begin_section(self.section)
        # Calling selector() may not be desirable 100% of the time, but as yet
        # I don't care
        out.css.write_class(out.css.selector(self.section, self.selector), self.props)

def emote_grid(emote_size, grid):
    emotes = []
    for (y, row) in enumerate(grid):
        for (x, names) in enumerate(row):
            emotes.append(Emote(emote_size, (-emote_size[0] * x, -emote_size[1] * y), *names))
    return emotes

def emote_list(map):
    emotes = []
    for (names, positioning) in map.items():
        size = positioning[0:2]
        offset = positioning[2:4]
        if isinstance(names, tuple) or isinstance(names, list): # Ew
            emotes.append(Emote(size, offset, *names))
        else:
            emotes.append(Emote(size, offset, names))
    return emotes
