#!/usr/bin/env python3
# -*- coding: utf8 -*-
################################################################################
##
## Copyright (C) 2012 Typhos
##
## This Source Code Form is subject to the terms of the Mozilla Public
## License, v. 2.0. If a copy of the MPL was not distributed with this
## file, You can obtain one at http://mozilla.org/MPL/2.0/.
##
################################################################################

import argparse
import time

import bplib
import bplib.condense
import bplib.objects

### Directive application

def overrides(sorting_rules, conflict_rules, base, new, name):
    for rule in sorting_rules:
        if rule == [base, "*"]: # Old subreddit wins all
            return False
        elif rule == [new, "*"]: # New subreddit wins all
            return True
        elif rule == [base, new]: # Old subreddit wins vs. new
            return False
        elif rule == [new, base]: # New subreddit wins vs. old
            return True

    if name in conflict_rules:
        # Does either subreddit explicitly win for this emote?
        favor = conflict_rules[name]
        if favor == base:
            return False
        elif favor == new:
            return True

    # No solution
    return None

def resolve_emotes(files, config):
    sorting_rules = config.pop("Sorting")
    conflict_rules = config.pop("Conflicts")

    # Converts a list of files into one big emote map
    emotes = {}
    sources = {}
    conflicts = {}

    # Sort all emotes by prioritization
    for file in files.values():
        for (name, emote) in file.emotes.items():
            if name not in emotes:
                emotes[name] = emote
                sources[name] = file
                continue

            result = overrides(sorting_rules, conflict_rules, sources[name].name, file.name, name)
            if result:
                if name in conflicts:
                    del conflicts[name]
                # Replace emote
                emotes[name] = emote
                sources[name] = file
            elif result is None:
                # ?!? previous file wins I guess
                conflicts[name] = (file, sources[name])

    for (name, (old, new)) in conflicts.items():
        print("ERROR: CONFLICT between %s and %s over %s" % (old.name, new.name, name))

    return emotes, sources

### Generation

def build_css(emotes):
    css_rules = {}

    for emote in emotes.values():
        for variant in emote.variants.values():
            selector, properties = variant.selector(), variant.to_css()
            if selector in css_rules and css_rules[selector] != properties:
                print("ERROR: Selector %r used twice!" % (selector))
            css_rules[selector] = properties

    return css_rules

def build_js_map(emotes, sources):
    emote_map = {}

    for (name, emote) in emotes.items():
        base = emote.base_variant()
        file = sources[name]

        assert name not in emote_map

        data = [0, file.file_id, 0]

        if hasattr(base, "size"): # FIXME
            data[2] = max(base.size)

        emote_map[name] = data

    return emote_map

def build_sr_data(files):
    sr_id2name = {}
    sr_name2id = {}

    for (name, file) in files.items():
        sr_id2name[file.file_id] = name
        sr_name2id[name] = file.file_id

    return sr_id2name, sr_name2id

AutogenHeader = """
/*
 * This file is AUTOMATICALLY GENERATED. DO NOT EDIT.
 * Generated at %s.
 */

""" % (time.strftime("%c"))

def dump_css(file, rules):
    file.write(AutogenHeader)
    for (selector, properties) in rules.items():
        property_strings = ["%s:%s" % i for i in properties.items()]
        s = "%s{%s}\n" % (selector, ";".join(property_strings))
        file.write(s)

def dump_js_map(file, js_map):
    file.write(AutogenHeader)
    _dump_js_obj(file, "emote_map", js_map)

def dump_sr_data(file, sr_id2name, sr_name2id):
    file.write(AutogenHeader)
    _dump_js_obj(file, "sr_id2name", sr_id2name)
    _dump_js_obj(file, "sr_name2id", sr_name2id)
    # exports is used in Firefox main.js, but doesn't exist elsewhere
    file.write("if(typeof(exports) !== 'undefined') {\n")
    file.write("    exports.sr_id2name = sr_id2name;\n")
    file.write("    exports.sr_name2id = sr_name2id;\n")
    file.write("}\n")

def _dump_js_obj(file, var_name, obj):
    file.write("var %s = " % (var_name))
    strings = ["%r:%r" % i for i in sorted(obj.items())]
    data = "{\n" + ",\n".join(strings) + "\n};\n"
    file.write(data)

### Main

def main():
    parser = argparse.ArgumentParser(description="Generate addon data files from emotes")
    parser.add_argument("-j", "--js", help="Output emote map JS file", default="build/emote-map.js")
    parser.add_argument("-s", "--srdata", help="Output subreddit data JS file", default="build/sr-data.js")
    parser.add_argument("-c", "--css", help="Output CSS file", default="build/emote-classes.css")
    parser.add_argument("--no-compress", help="Disable CSS compression", action="store_true")
    args = parser.parse_args()

    files = {}

    with open("data/rules.yaml") as file:
        config = bplib.load_yaml_file(file)

    print("Loading emotes")
    loader = bplib.objects.SubredditLoader()
    for subreddit in config["Subreddits"]:
        file = loader.load_subreddit(subreddit)
        if file is None:
            continue
        files[file.name] = file

    print("Processing")
    emotes, sources = resolve_emotes(files, config)

    css_rules = build_css(emotes)
    js_map = build_js_map(emotes, sources)
    sr_id2name, sr_name2id = build_sr_data(files)
    if not args.no_compress:
        bplib.condense.condense_css(css_rules)

    print("Dumping")
    with open(args.css, "w") as file:
        dump_css(file, css_rules)
    with open(args.js, "w") as file:
        dump_js_map(file, js_map)
    with open(args.srdata, "w") as file:
        dump_sr_data(file, sr_id2name, sr_name2id)

if __name__ == "__main__":
    main()
